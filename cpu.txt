# specs2 processor architecture

the specs2 processor architecture is described in this document.

# revisions

three revisions of the processor exist:

- r1: found in specs2 r1/r2.
  - 16-bit data bus
  - 24-bit addressing
  - up to 6.5MHz
- r2: found in specs2 r3.
  - 32-bit data bus
  - 24-bit addressing
  - up to 20MHz
- r3: found in specs2 r4.
  - 32-bit data bus
  - 32-bit addressing
  - up to 40MHz

## detecting processor revision

upon boot, the A register is initialized with the processor revision:

- r1: ???
- r2: ???
- r3: ???

# registers

eight 32-bit registers:

- accumulators: A, B, C, D
- index: W, X, Y, Z

indexed operations may only use the index registers.
the Y register increases when used on an indexed operation, unless DisableY is set.
the Z register increases (or decreases) when used on an indexed operation.

special registers:

- F: processor flags, from most to least significant: NDKEFIZC (8-bit)
  - Negative: set whenever the sign bit has changed in the last operation.
  - DisableY: do not auto-increment Y when read.
  - Kernel: whether the processor is in kernel mode or not.
  - Exception: whether an exception was raised.
  - FlipZ: if set, Z decreases when read (instead of increasing).
  - Interrupt: if set, interrupts are ignored.
  - Zero: set whenever the last operation yielded zero.
  - Carry: set when the value overflows after an addition/subtraction.
- SP: stack pointer (32-bit)
- ST: stack top (32-bit)
- SB: stack bottom (32-bit)
- PC: program counter (32-bit)
- CC: cycle counter (32-bit)
- EX: exception code (8-bit)
  - 0: no exception
  - 1: address read
  - 2: address write
  - 3: execute
  - 4: arithmetic (e.g. divide by zero)
  - 5: privilege violation
  - 6: illegal instruction
  - 7: stack error
  - 8: call stack overflow
  - 9: illegal halt 
  - 10: user exception
- IR: interrupt request code (8-bit)
- EV: exception handling vector
- IV: interrupt vector table pointer

# prefetching

the processor is able to fetch one instruction ahead of time in order to cut one cycle per instruction.

the following instructions are prefetch barriers:

- any instruction that alters PC (jumps/branches/jsr/ret)
- the flush instruction

# note about 32-bit operations

the processor has a 16-bit data bus, which means these will take an additional cycle (except register to register).

later revisions of the processor have a 32-bit dats bus instead.

# instruction set

the instructions are encoded in a way that is similar to that of the 6502's.
the first byte is the instruction code, and the rest are parameters.

for operations which involve registers, the following 8-bit parameter is used:
- bit 0-2: destination
- bit 4-6: source/index
  - bit 6 is ignored if this is an index (only W/X/Y/Z registers are usable).

for sha/shl, bit 7 indicates direction of shift and bit 3 indicates whether source actually is shift amount (from 0 to 7).

for branch instructions, a 16-bit offset is used.

instructions are categorized by groups:
- 00-3F: operations, char (8-bit)
- 40-7F: operations, short (16-bit)
- 80-BF: operations, int (32-bit)
- C0-FF: conditions/special

# operations

## add

- register:
  - `00`: addc R, R
  - `40`: adds R, R
  - `80`: add  R, R
- immediate:
  - `01`: addc R, #$val
  - `41`: adds R, #$val
  - `81`: add  R, #$val
- absolute:
  
- indexed:
- indirect absolute:
- indirect offset:
- indirect indexed:
- indirect register:

unfinished!!!!!

instruction                     opcode
------------------------------------------
add R, R                        $80
add R, #$val                    $81
add R, $val                     $82
add R, $val+R                   $83
add R, ($val)                   $84
add R, ($val)+R                 $85
add R, ($val+R)                 $86
add R, (R)                      $87
sub R, R                        $88
sub R, #$val                    $89
sub R, $val                     $8a
sub R, $val+R                   $8b
sub R, ($val)                   $8c
sub R, ($val)+R                 $8d
sub R, ($val+R)                 $8e
sub R, (R)                      $8f
and R, R                        $90
or R, R                         $91
xor R, R                        $92
cmp R, R                        $93
and R, #$val                    $94
or R, #$val                     $95
xor R, #$val                    $96
cmp R, #$val                    $97
and R, $addr                    $98
or R, $addr                     $99
xor R, $addr                    $9a
cmp R, $addr                    $9b
and R, (R)                      $9c
or R, (R)                       $9d
xor R, (R)                      $9e
cmp R, (R)                      $9f
mov R, R                        $a0
mov R, #$val                    $a1
mov R, $addr                    $a2
mov R, $addr+R                  $a3
mov R, ($addr)                  $a4
mov R, ($addr)+R                $a5
mov R, ($addr+R)                $a6
mov R, (R)                      $a7
mov $dest, #$val                $a8
mov $dest, $src                 $a9
mov $addr, R                    $aa
mov $addr+R, R                  $ab
mov ($addr), R                  $ac
mov R, ($addr)+R                $ad
mov R, ($addr+R)                $ae
mov (R), R                      $af
sha R                           $b0
shl R                           $b1
rol R, R                        $b2
ror R, R                        $b3
swp R, R                        $b4
push R                          $b5
pop R                           $b6
push #$val                      $b7
mul R, R                        $b8
mul R, #$val                    $b9
mulu R, R                       $ba
mulu R, #$val                   $bb
div R, R                        $bc
div R, #$val                    $bd
divq R                          $be
divr R                          $bf


# conditions/special

instruction                     opcode
------------------------------------------
beq $off                        $c0
bne $off                        $c1
bmi $off                        $c2
bpl $off                        $c3
bcs $off                        $c4
bcc $off                        $c5
loopc $off                      $c6
loops $off                      $c7
bbs R.#b, $off                  $c8
bbc R.#b, $off                  $c9
bbs R.R, $off                   $ca
bbc R.R, $off                   $cb
mov R, EX                       $cc
mov R, IR                       $cd
loop $off                       $ce
bra $off                        $cf
jmp $addr                       $d0
jmp ($addr)                     $d1
jsr $addr                       $d2
jsr ($addr)                     $d3
extc R                          $d4
exts R                          $d5
mov EV, R                       $d6
mov IV, R                       $d7
mov R, ST                       $d8
mov ST, R                       $d9
mov R, SB                       $da
mov SB, R                       $db
flush                           $dc
brk                             $dd
hlt                             $de
ret                             $df
set n                           $e0
set d                           $e1
set k                           $e2
set e                           $e3
set f                           $e4
set i                           $e5
set z                           $e6
set c                           $e7
clr n                           $e8
clr d                           $e9
clr k                           $ea
clr e                           $eb
clr f                           $ec
clr i                           $ed
clr z                           $ee
clr c                           $ef
pushds                          $f0
pushall                         $f1
popds                           $f2
popall                          $f3
mov R, SP                       $f4
mov SP, R                       $f5
movc R, F                       $f6
mov R, PC                       $f7
lcc R                           $f8
scc R                           $f9
rcc                             $fa
                                $fb
nop                             $fc
                                $fd
                                $fe
                                $ff
